% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale.cv.R
\name{downscale.cv}
\alias{downscale.cv}
\title{Downscale climate data and reconstruct the temporal serie by splitting the data in k folds.}
\usage{
downscale.cv(x, y, method, folds = 4, type = "chronological",
  scale.list = NULL, global.vars = NULL, combined.only = TRUE,
  spatial.predictors = NULL, local.predictors = NULL,
  extended.predictors = NULL, filter = NULL, ...)
}
\arguments{
\item{x}{The input grid (admits both single and multigrid, see \code{\link[transformeR]{makeMultiGrid}}). It should be an object as returned by \pkg{loadeR}.}

\item{y}{The observations dataset. It should be an object as returned by \pkg{loadeR}.}

\item{method}{A string value. Type of transer function. Options are c("analogs","GLM","NN").}

\item{folds}{Could be a fraction, value between (0,1) indicating the fraction of the data that will define the train set, 
or an integer indicating the number of folds. It can also be a list of folds indicating the years of each fold.}

\item{type}{A string, c("chronological","random"). Indicates how to split the data in folds. Default is "chronological".}

\item{scale.list}{A list of the parameters related to scale grids. This parameter calls the function \code{\link[transformeR]{scaleGrid}}. See the function definition for details on the parameters accepted.}

\item{global.vars}{An optional character vector with the short names of the variables of the input x multigrid to be retained as global predictors 
(use the getVarNames helper if not sure about variable names). 
This argument just produces a call to subsetGrid, but it is included here for better flexibility in downscaling experiments (predictor screening...). 
For instance, it allows to use some specific variables contained in x as local predictors and the remaining ones, specified in subset.vars, 
as either raw global predictors or to construct the combined PC.}

\item{combined.only}{Optional, and only used if spatial.predictors parameters are passed. Should the combined PC be used as the only global predictor? Default to TRUE. 
Otherwise, the combined PC constructed with which.combine argument in prinComp is append to the PCs of the remaining variables within the grid.}

\item{spatial.predictors}{Default to NULL, and not used. Otherwise, a named list of arguments in the form argument = value, 
with the arguments to be passed to prinComp to perform Principal Component Analysis of the predictors grid (x). 
See Details on principal component analysis of predictors.}

\item{local.predictors}{Default to \code{NULL}, and not used. Otherwise, a named list of arguments in the form \code{argument = value},
with the following arguments:
\itemize{
  \item \code{neigh.vars}: names of the variables in \code{x} to be used as local predictors
  \item \code{neigh.fun}: Optional. Aggregation function for the selected local neighbours.
  The aggregation function is specified as a list, indicating the name of the aggregation function in
   first place (as character), and other optional arguments to be passed to the aggregation function.
   For instance, to compute the average skipping missing values: \code{neigh.fun = list(FUN= "mean", na.rm = TRUE)}.
   Default to NULL, meaning that no aggregation is performed.
  \item \code{n.neighs}: Integer. Number of nearest neighbours to use. If a single value is introduced, and there is more
  than one variable in \code{neigh.vars}, the same value is used for all variables. Otherwise, this should be a vector of the same
  length as \code{neigh.vars} to indicate a different number of nearest neighbours for different variables.
}}

\item{extended.predictors}{This is a parameter related to the extreme learning machine and reservoir computing framework where input data is randomly projected into a new space of size \code{n}. Default to \code{NULL}, and not used. Otherwise, a named list of arguments in the form \code{argument = value},
with the following arguments:
\itemize{
  \item \code{n}: A numeric value. Indicates the size of the random nonlinear dimension where the input data is projected.
  \item \code{module}: A numeric value (Optional). Indicates the size of the mask's module. Belongs to a specific type of ELM called RF-ELM.
}}

\item{filter}{A logical expression (i.e. = ">0"). This will filter all values that do not accomplish that logical statement. Default is NULL.}

\item{...}{Optional parameters. These parameters are different depending on the method selected. 
Every parameter has a default value set in the atomic functions in case that no selection is wanted. 
Everything concerning these parameters is explained in the section \code{Details} of the function \code{\link[downscaleR]{downscale.train}}. However, if wanted, the atomic functions can be seen here: 
\code{\link[downscaleR]{glm.train}} and \code{\link[deepnet]{nn.train}}.}
}
\value{
The reconstructed downscaled temporal serie.
}
\description{
Downscale climate data and reconstruct the temporal serie by splitting the data in k folds. 
Statistical downscaling methods are: analogs, generalized linear models (GLM) and Neural Networks (NN).
}
\details{
The functon relies on \code{\link[downscaleR]{prepareData}}, \code{\link[downscaleR]{prepareNewData}}, \code{\link[downscaleR]{downscale.train}}, and \code{\link[downscaleR]{downscale.predict}}. 
For more information please visit these functions.
If the variable to downscale is the precipitation and it is a binary variable, then two temporal series will be returned:
1) The temporal serie with binary values filtered by a threshold adjusted by the train dataset, see \code{\link[transformeR]{binaryGrid}} for more details.
2) The temporal serie with the results obtained by the downscaling, without any binary converting process.
We recommend to get rid of the NaN/NA when dealing with multisite mode.
}
\examples{
require(transformeR)
data(NCEP_Iberia_hus850, NCEP_Iberia_ta850)
x <- makeMultiGrid(NCEP_Iberia_hus850, NCEP_Iberia_ta850)
x <- subsetGrid(x, years = 1985:1995)
# Loading predictands
y <- VALUE_Iberia_pr
y <- getTemporalIntersection(obs = y, prd = x, "obs" )
x <- getTemporalIntersection(obs = y, prd = x, "prd" )
# Reconstructing the downscaled serie in 3 folds
pred <- downscale.cv(x,y,folds = 3, type = "chronological",
                     scale.list = list(type = "standardize"),
                     method = "GLM", filter = ">0")
# ... or with dates ...
pred <- downscale.cv(x,y,type = "chronological",
                     method = "GLM", filter = ">0",
                     scale.list = list(type = "standardize"),
                     folds = list(c("1985","1986","1987","1988"),
                                  c("1989","1990","1991","1992"),
                                  c("1993","1994","1995")))
# Reconstructing the downscaled serie in 3 folds with spatial predictors
pred <- downscale.cv(x,y,folds = 3,type = "chronological",
                     scale.list = list(type = "standardize"),
                     method = "GLM", family = Gamma(link = "log"), filter = ">0",
                     spatial.predictors = list(which.combine = getVarNames(x),v.exp = 0.9))
# Reconstructing the downscaled serie in 3 folds with local predictors.
pred <- downscale.cv(x,y,folds = 3,type = "chronological",
                     scale.list = list(type = "standardize"),
                     method = "GLM", filter = ">0",
                     local.predictors = list(vars = "hus@850", n = 4))
}
\author{
J. Bano-Medina
}
