% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/downscale.R
\name{downscale}
\alias{downscale}
\title{Perfect-prog downscaling}
\usage{
downscale(
  y,
  x,
  newdata = x,
  method = c("analogs", "glm", "lm"),
  simulate = c(FALSE, TRUE),
  n.analogs = 1,
  sel.fun = c("mean", "wmean", "max", "min", "median"),
  wet.threshold = 0.1,
  n.pcs = NULL,
  cross.val = c("none", "loocv", "kfold"),
  folds = NULL
)
}
\arguments{
\item{y}{The observations dataset. It should be an object as returned by \pkg{loadeR}.}

\item{x}{The input grid. It should be an object as returned by \pkg{loadeR}.}

\item{newdata}{It should be an object as returned by \pkg{loadeR} and consistent with x. Default is newdata = x.}

\item{method}{Downscaling method. Options are c = ("analogs","glm","lm"). Glm can only be set when downscaling precipitation.}

\item{simulate}{A logic value indicating whether we want to simulate or not based on the GLM distributional parameters. Only relevant when perdicting with a GLM. Default to FALSE.}

\item{n.analogs}{Applies only when \code{method="analogs"} (otherwise ignored). Integer indicating the number of closest neigbours to retain for analog construction. Default to 1.}

\item{sel.fun}{Applies only when \code{method="analogs"} (otherwise ignored). Criterion for the construction of analogs when several neigbours are chosen. Ignored when \code{n = 1}.
Current values are \code{"mean"} (the default), \code{"wmean"},  \code{"max"},  \code{"min"} and  \code{"median"}.}

\item{wet.threshold}{Value below which precipitation amount is considered zero}

\item{n.pcs}{Integer indicating the number of EOFs to be used as predictors}

\item{cross.val}{Should cross-validation be performed? methods available are leave-one-out (\code{"loocv"})
and k-fold (\code{"kfold"}). Default to \code{"none"}, which does not perform cross-validation.}

\item{folds}{This arguments controls the number of folds, or how these folds are created (ignored if \code{cross.val = "loocv"}). Folds are always splitted chronologically. If it is given as a fraction in the range (0-1), 
it splits the data in two subsets, one for training and one for testing, being the given value the fraction of the data used for training (i.e., 0.75 will split the data so that 75\% of the instances are used for training, and the remaining 25\% for testing). 
In case it is an integer value, it sets the number of folds in which the data will be split (e.g., \code{folds = 10} for the classical 10-fold cross validation). 
Alternatively, this argument can be passed as a list, each element of the list being a vector of years to be included in each fold (See examples).}
}
\value{
The prediction structure.
}
\description{
Workhorse function to call the different perfect-prog downscaling methods
}
\details{
\strong{Scaling and centering}
When the climate variables are used as predictors instead of the PCs, these are previously centered and scaled
using the mean and sigma parameters globally computed for the whole spatial domain.
}
\examples{
\donttest{
require(transformeR)
require(climate4R.datasets)
data("NCEP_Iberia_hus850")
data("NCEP_Iberia_ta850")
x <- makeMultiGrid(NCEP_Iberia_hus850, NCEP_Iberia_ta850)
newdata <- subsetGrid(x, years = 1994:1995)
x <- subsetGrid(x, years = 1985:1993)
# Loading predictands
data("VALUE_Iberia_pr")
y <- VALUE_Iberia_pr
y <- getTemporalIntersection(obs = y,prd = x, "obs" )
x <- getTemporalIntersection(obs = y,prd = x, "prd" )
### Analogs ###
# None
yp <- downscale(y, x, method = "analogs")
yp <- downscale(y, x, newdata, method = "analogs")
# kfold
yp <- downscale(y, x, method = "analogs", n.pcs = 15,
                cross.val = "kfold", folds = list(c(1985, 1986, 1987),
                                                  c(1988, 1989, 1990),
                                                  c(1991, 1992, 1993)))
# Leave-one-year-out
yp <- downscale(y, x, method = "analogs", n.pcs = 15,
                cross.val = "loocv")

### GLM ###
# None
yp <- downscale(y, x, method = "glm", simulate = FALSE, n.pcs = 10,
                wet.threshold = 1)
yp <- downscale(y, x, method = "glm", simulate = TRUE, n.pcs = 10,
                wet.threshold = 1)
# kfold
yp <- downscale(y, x, method = "glm", simulate = FALSE, n.pcs = 10,
                cross.val = "kfold", folds = list(c(1985, 1986, 1987),
                                                  c(1988, 1989, 1990),
                                                  c(1991, 1992, 1993)))
}
}
\seealso{
downscaleTrain for training a downscaling model
downscalePredict for prediction for a a test dataset with a trained model for 
downscaleCV for automatic cross-validation 
\href{https://github.com/SantanderMetGroup/downscaleR/wiki/training-downscaling-models}{downscaleR Wiki} for downscaling seasonal forecasting and climate projections.

Other downscaling.functions: 
\code{\link{downscaleCV}()},
\code{\link{downscaleChunk}()},
\code{\link{downscalePredict}()},
\code{\link{downscaleTrain}()}
}
\concept{downscaling.functions}
